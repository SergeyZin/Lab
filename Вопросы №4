1. Допустим, тест на некое заболевание R дал положительный ответ, хотя на самом деле у испытуемого нет этого заболевания. Какую ошибку допустил тест?
  Ошибка теста заключалась в том, что он выдал положительный результат на наличие заболевания у испытуемого, в то время как на самом деле испытуемый был здоров и не имел этого заболевания. Такая ситуация называется ложноположительным результатом (False Positive, FP).
  Иными словами, тест ошибочно классифицировал здорового человека как больного, указав на присутствие заболевания, которого на самом деле не было. Тест неверно идентифицировал отсутствие заболевания как его наличие.

2. Пусть в матрице ошибок TP = 5, TN = 90, FP = 10, FN = 5. Оцените метрики классификации для такой матрицы ошибок.
  Точность (Accuracy): (TP + TN) / (TP + TN + FP + FN) = (5 + 90) / 100 = 0.95
  Чувствительность (Sensitivity, Recall): TP / (TP + FN) = 5 / (5 + 5) = 0.5
  Специфичность (Specificity): TN / (TN + FP) = 90 / (90 + 10) = 0.9
  Полнота (Precision): TP / (TP + FP) = 5 / (5 + 10) = 0.33
  F1-мера: 2 * (Precision * Recall) / (Precision + Recall) = 2 * (0.33 * 0.5) / (0.33 + 0.5) ≈ 0.38

3. Допустим, есть два классификатора: первый классификатор имеет долю правильных ответов 95 %, чувствительность 99 %, специфичность 50 %; второй классификатор имеет долю правильных ответов 87 %, чувствительность 84 %, специфичность 94 %. Что вы можете сказать о данных, используемых для классификации? Какой из этих классификаторов надежнее (при условии, что важно определение обоих классов)?
  Первый классификатор: высокая чувствительность, низкая специфичность, много ложноположительных результатов.
  Второй классификатор: сбалансированные показатели чувствительности и специфичности, более надежный для обоих классов.
  Различия в структуре и распределении данных для каждого классификатора, влияющие на их производительность.

4. Перечислите возможные гиперпараметры модели логистической регрессии:
  Регуляризация 
  Метод оптимизации и его параметры
  Число итераций для обучения модели
  Функция потерь

5. Для набора данных Cars проанализируйте веса моделей при использовании только числовых признаков. Назовите параметр, который в наибольшей степени связан с целевой переменной.
  Пример кода:
  import pandas as pd
  from sklearn.model_selection import train_test_split
  from sklearn.linear_model import LinearRegression
  import numpy as np
  df = pd.read_csv('cars.csv')
  numerical_features = df.select_dtypes(include=[np.number]).columns.tolist()
  numerical_features.remove('Price(euro)') 
  X = df[numerical_features]
  y = df['Price(euro)']
  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
  model = LinearRegression()
  model.fit(X_train, y_train)
  coefficients = pd.Series(model.coef_, index=numerical_features)
  coefficients = coefficients.sort_values(ascending=False)
  print("Веса модели линейной регрессии:")
  print(coefficients)
  most_related_feature = coefficients.idxmax()
  print(f'Параметр, который в наибольшей степени связан с ценой: {most_related_feature}')
  Порядок выполнения пошагово:
  Импорт библиотек: pandas, scikit-learn, numpy
  Загрузка данных из файла 'cars.csv' в DataFrame
  Отбор только числовых признаков, исключая целевую переменную
  Разделение данных на обучающую и тестовую выборки
  Обучение модели линейной регрессии на обучающих данных
  Получение и сортировка весов признаков для определения наиболее влиятельного

6. Оцените значение функции сигмоиды σ(z) для z = 0.25.
  σ(0.25) = 1 / (1 + e^(-0.25)) ≈ 0.5596
  Для вычисления значения функции сигмоиды σ(z) при z = 0.25 на Python, мы можем использовать библиотеку math для доступа к функции экспоненты. Функция сигмоиды определяется формулой:
  [ \sigma(z) = \frac{1}{1 + e^{-z}} ]
  где ( e ) — основание натурального логарифма.
  import math
  def sigmoid(z):
      """Вычисление значения сигмоидной функции"""
      return 1 / (1 + math.exp(-z))
  z = 0.25
  sigmoid_value = sigmoid(z)
  print(f"Значение функции сигмоиды σ({z}) = {sigmoid_value:.4f}")
  Порядок выполнения пошагово:
  Функция sigmoid вычисляет значение логистической функции
  Использование math.exp для вычисления e^(-z)
  Форматирование вывода с четырьмя знаками после запятой
  Получение приближенного значения 0.5596 для данного входа z

7. Оцените значение производной функции сигмоиды σ'(z) для z = –3.
  σ'(-3) = σ(-3) * (1 - σ(-3)) = (1 / (1 + e^3)) * (e^3 / (1 + e^3)) ≈ 0.0474
  Для вычисления значения производной функции сигмоиды ( \sigma'(z) ) при ( z = -3 ) в Python, мы снова воспользуемся библиотекой math. Производная функции сигмоиды по ( z ) выражается через саму функцию сигмоиды следующим образом:
  [ \sigma'(z) = \sigma(z) \cdot (1 - \sigma(z)) ]
  import math
  def sigmoid(z):
      """Вычисление значения сигмоидной функции"""
      return 1 / (1 + math.exp(-z))
  def sigmoid_derivative(z):
      """Вычисление значения производной сигмоидной функции"""
      sig = sigmoid(z)
      return sig * (1 - sig)
  z = -3
  sigmoid_derivative_value = sigmoid_derivative(z)
  print(f"Значение производной функции сигмоиды σ'({z}) = {sigmoid_derivative_value:.4f}")
  Функция sigmoid вычисляет значение сигмоидной функции
  Функция sigmoid_derivative использует значение sigmoid(z) для вычисления производной
  Входное значение z = -3 передается для вычисления производной
  Результат производной выводится с форматированием до четырех знаков после запятой

8. Назовите, к какому классу следует отнести результат логистической модели для z = 0.1, если порог равен 0.6.
  Классификация по логистической модели для z = 0.1 с порогом 0.6:
  Поскольку σ(0.1) ≈ 0.5244, что меньше порога 0.6, результат классификации будет отнесен к отрицательному классу.
  Для выполнения классификации по логистической модели на Python, мы сначала определим функцию сигмоиды, которая будет вычислять вероятность принадлежности к положительному классу. Затем мы создадим функцию для классификации, которая принимает значение ( z ) и порог (threshold), и на основании сравнения значения сигмоиды с порогом определяет класс объекта.
  import mat
  def sigmoid(z):
      """Вычисление значения сигмоидной функции"""
      return 1 / (1 + math.exp(-z))
  def classify(z, threshold=0.6):
      """Классификация с использованием порога для сигмоидной функции"""
      probability = sigmoid(z)
      if probability >= threshold:
          return 'положительный класс'
      else:
          return 'отрицательный класс'
  z = 0.1
  classification_result = classify(z)
  print(f"Классификация для z = {z} с порогом 0.6: {classification_result}")

9. Оцените значение функции потерь (бинарной кросс-энтропии) для предсказания модели y' = 0.1 и целевой переменной y = 1.
  Для оценки значения функции потерь бинарной кросс-энтропии (binary cross-entropy loss) для предсказания модели y' = 0.1 и целевой переменной y = 1 можно использовать следующую формулу:
  BCE_loss = -y * log(y') - (1 - y) * log(1 - y')
  Где:
  y - истинное целевое значение (0 или 1)
  y' - предсказанное значение модели (вероятность принадлежности к классу 1)
  Подставляя заданные значения y = 1 и y' = 0.1, получаем:
  BCE_loss = -(1 * log(0.1)) - (0 * log(1 - 0.1))
  BCE_loss = -(-2.30259) - 0
  BCE_loss = 2.30259
  Таким образом, значение функции потерь бинарной кросс-энтропии для предсказания модели y' = 0.1 и целевой переменной y = 1 равно 2.30259.
